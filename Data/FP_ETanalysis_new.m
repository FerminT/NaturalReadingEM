classdef FP_ETanalysis_new
    properties
    end
    methods(Static)
        function ESTIM = generateESTIM(DATA, palstruct, preds,oracInfo)
                [~,ind] = sort([DATA.ind]);
                ESTIM = DATA(ind);
                ESTIM = rmfield(ESTIM,{'correcta', 'opcion_elegida',...
                                       'tresp_ojo1','tresp_ojo2',...
                                       'condicion1', 'condicion2',...
                                       'opciones', 'indopcion'});
                ESTIM = parseSentence(ESTIM);
                ESTIM = addLexEspFreq(ESTIM,palstruct);
                ESTIM = addPred(ESTIM, preds);
                ESTIM = addOrigTextInfo(ESTIM, oracInfo);
        end
        function all   = loadASC(filename)
            % Parser for the ASC file generated by edf2asc, into a Matlab structure
            % all = loadASC(filename) 
            %
            % filename: ascii filename (w/o extension)
            % ascii file should be created by "edf2asc ascfilename", with default settings
            %
            %
            % structure fields:
            %             modo: mode: ('BTABLE'|'RTABLE'|'MTABLE'}
            %              ojo: eye: {'BOTH'|'LEFT'|'RIGHT'}
            %            srate: sampling rate: {250|500|1000}
            %     driftcorrect: 2x2 matrix of drift correction
            %      headerlines: number of lines in the header, before the beginning of the data
            %           header: a cell array containing the header lines
            %       fieldnames: some help lines containing the definitions of columns in samples, saccades, blinks and fixations
            %          samples: Nsam x 4 or Nsam x 7 matrix containing all eye samples (see fieldnames)
            %            resac: Nsac x 9 right eye saccades (see filenames) 
            %            lesac: Nsac x 9 left eye saccades (see fieldnames)
            %            refix: Nfix x 6 right eye fixations (see fieldnames)
            %            lefix: Nfix x 6 left eye fixations (see fieldnames)
            %            rebli: Nbli x 3 right eye blinks (see fieldnames)
            %            lebli: Nbli x 3 left eye blinks (see fieldnames)
            %          msgtime: Nmsg x 1 the times of the messages
            %              msg: Nmsc x 1 cells with the text of the messages
            %
            % Diego Shalom (diegoshalom (at) gmail.com)
            % Laboratorio de Neurociencia Integrativa
            % Departamento de Fisica - Facultad de Ciencias Exactas y Naturales
            % Universidad de Buenos Aires - Buenos Aires - Argentina
            % Dec-2013
            %
            % Update: Bruno Bianchi (brunobian (at) gmail.com)
            % Laboratorio de Inteligencia Artificial Aplicada
            % Departamento de Computacion - Facultad de Ciencias Exactas y Naturales
            % Universidad de Buenos Aires - Buenos Aires - Argentina
            % Abr-2018
            
            ascfilename = [filename '.asc'];
            if nargin~=1
                disp('Parser for the ASC file generated by edf2asc, into a Matlab structure')
                disp('  all = loadASC(''mytest.asc'')') 
                all=[];
                return
            end
                  
            if ~exist(ascfilename,'file')
                fprintf('Error: File not found.\n')
                fprintf('%s\n', ascfilename)
            
                all=[];
                return
            end
            
            tmp = split(ascfilename,'/');
            disp(['Analysis of file: ' tmp{end}])
            
            all = []; tmp = [];
            
            C = loadFile(ascfilename);
            
            [tmp.blockLim, tmp.headLim, tmp.expLim] = findCalibrations(C);
            
            % if there was a fail start there is 2 calibrations for 1 block
            diffStarts = diff(tmp.headLim(:,1));
            index      = find(diffStarts == 0);
            tmp.blockLim(index,:) = [];
            tmp.headLim(index,:)  = [];
            tmp.expLim(index,:)   = [];
            
            lToStart = tmp.headLim(:,2)-tmp.headLim(:,1);
            
            for i = 1:(size(tmp.expLim,1))
                thisPart.blockLim = tmp.blockLim(i,:);
                thisPart.headLim  = tmp.headLim(i,:);
                thisPart.expLim   = tmp.expLim(i,:);
                thisPart.header   = C(thisPart.headLim(1):thisPart.headLim(2));   
                thisBlock         = C(thisPart.blockLim(1):thisPart.blockLim(2));   
                thisPart          = analysisCalibration(thisBlock, thisPart);
                thisPart          = msg2event(thisPart);
%                 if i==1
%                     thisPart = removePractice(thisPart,5);
%                 end
                all = [all thisPart];
            end
            save([filename '_all'],'all')
        end
        function DATA  = addFieldsEstim(DATA,ESTIM,campos)
            try
                fprintf('\tAdd fields from ESTIM to DATA\n')
                for i=1:length(DATA)
                    tESTIM = ESTIM(DATA(i).ind == [ESTIM.ind]);
                    for indcampo=1:length(campos)
                        DATA(i).(campos{indcampo}) = tESTIM.(campos{indcampo});
                    end
                end
            catch ME
                ME
                keyboard
            end
        end
        function [DATA_new, all_new] = addAllToDATA(DATA, all, init, suj, iSuj)
            all_new = [];
            DATA_new = [];
            for iBlock = 1:length(all)

                [tmpDATA, tmpAll] = recognizeLetterAndWord(DATA,...
                                          all(iBlock),init,...
                                          iBlock, suj, iSuj);
    
                all_new = [all_new tmpAll];
                DATA_new = [DATA_new tmpDATA];
            end
        end
        function [DATA, FIX, nFixRM] = addEm(DATA, iSuj,...
                                             minfixdur, maxfixdur)
            
            try
        %                 keyboard
                eye = DATA(1).eye;
                fprintf('Adding Eye Movemnt Data into DATA\n')
                fprintf('\tUsing %s eye\n', eye)
                eye = eye(1);
        
        
                FIX = struct([]);
                for indtrial = 1:length(DATA)
                    DATA(indtrial).befix = DATA(indtrial).([lower(eye) 'efix']);
                    DATA(indtrial).befixasig  = DATA(indtrial).([lower(eye) 'efixasig']);                    
                    DATA(indtrial).befixletra = DATA(indtrial).([lower(eye) 'efixletra']);

                    fix      = DATA(indtrial).befix;
                    fixAsig  = DATA(indtrial).befixasig; 
                    fixChar  = DATA(indtrial).befixletra;
        
                    for iFix = 1:size(fix,1)
                        FIX(end+1).subj   = iSuj;
                        FIX(end).trial    = indtrial;
                        FIX(end).roi      = fixAsig(iFix);
                        FIX(end).location = fixChar(iFix);
                        FIX(end).dur      = fix(iFix,3);
                        FIX(end).tini     = fix(iFix,1);
                        %los primeros 5 campos tienen que ser estos. los
                        %siguientes no se usan en em
                        FIX(end).xpos     = fix(iFix,4);                        
                        FIX(end).ypos     = fix(iFix,5);
                    end         
                end
                
                % Delete too short or too long fixations
                indRm  = [FIX.dur] > maxfixdur | [FIX.dur] < minfixdur;
                FIX    = FIX(~indRm);
                nFixRM = sum(indRm);
                fprintf('\t%d Fixations deleted, %d left\n', nFixRM, length(FIX))
        
                fpem = FP_EmConection;
                % necesito una estructura que tenga los siguientes campos:
                %   subj: sumero de sujeto
                %   trial: numero de trial dentro del sujeto (puede ser pantalla en nuestro caso)
                %   roi: numero de palabra en la que fijo, dentro del trial 
                %   dur: duracion de la fijacion
                %   tini: tiempo inicial de la fijacion, solo para ordenar por tiempo.                
                max_roi = max([DATA.pos]);
                OUT=fpem.conexion_em_matlab(FIX,max_roi);                
                for indtrial=1:length(DATA)
                    index=[OUT.trial]==indtrial;%todas las palabras de este trial                     
                    % FFD	(First Fixation Duration) Duration of the first fixation on a position if (and only if) the fixation was progressive. Zero otherwise.
                    % SFD	(Single Fixation Duration) Duration of the fixation on a position if it was the *only* fixation on this region, i.e. if no subsequent fixation on this position followed. Zero if there were several fixations on this region.
                    % FPRT (First Pass Reading Time, Gaze Duration) Sum of all first-pass fixation durations on a region before *any* other region is fixated. (What exactly constitutes a first pass is determined by the parameter 'regressiveFirstPass'.)
                    % RBRT (Right Bounded Reading Time) Sum of all first-pass fixation durations on a position before another position to the *right* is fixated. (What exactly constitutes a first pass is determined by the parameter 'regressiveFirstPass'.)
                    % RPD	(Regression Path Duration, Go-Past Duration) Sum of all first-pass fixation durations on a position n and all preceding positions in the time period between the first fixation on n and the first fixation on anything to the right of n.
                    % CRPD (Cumulative Regression Path Duration) The CRPD of position n is the total amount of time a participant spent reading the sentence until reaching region n+1. It is the sum of the RPDs of all preceding regions and the RPD of the current region.
                    % TFT	(Total Fixation Time) Sum of all fixation durations on a region.
                    % RRT	(Re-reading Time) Sum of all second-pass fixation durations. (RRT = TFT - FPRT)
                    % RRTR (ReReading Time Regressive) Sum of all second-pass fixation durations on a position that occured *after* a fixation on a region further to the right. (RRTR = TFT - RBRT)
                    % RRTP (ReReading Time Progressive) Sum of all second-pass fixation durations on a position that took place *before* a fixation on a region further to the right. (RRTP = RBRT - FPRT)
                    % FFP	(First Fixation Progressive) 0 if material downstream was viewed before the first fixation on this position, 1 otherwise.
                    % TRC	(Total Regression Count) Total number of regressions from this position.
                    % RBRC (Right-Bounded Regression Count) Number of regressions from this position given *before* any region further to the right has been fixated.                    
                    % TRI (Total Regressions In) Number of regressions TO this position.                    
                    % FFLP (First Fixation Location Progresive)
                    % LFLP (Last Fixation Location Progresive)
                    DATA(indtrial).OJO=eye;
                    campos_pasar={'FFD' 'SFD' 'FPRT' 'RBRT' 'RPD'  ... 
                        'CRPD' 'TFT' 'RRT' 'RRTR' 'RRTP' 'FFP' 'TRC' 'RBRC' ...
                        'LPRT' 'TRI' 'FFLP' 'LFLP'};                    
                    for i=1:length(campos_pasar)
                        campo=campos_pasar{i};
                        temp=[OUT(index).(campo)];
                        DATA(indtrial).(['EM_' campo])=temp;
                    end 
                    DATA(indtrial).EM_NLaunchSite = addNLaunchSite(DATA(indtrial));
                end
              catch ME
                ME
                keyboard
            end
        end
        
        % plot functinos
        function figFix2FirstChar(DATA)
            figure(9878);clf
            subplot(1,2,1)
            temp=[DATA.diflefix1l]';
%             keyboard
            scatter(temp(:,1),temp(:,2),5,1:length(temp))
            xlim([-100 100]);ylim([-100 100])
            error=sqrt(temp(:,1).^2+temp(:,2).^2);
            str=sprintf('fix first letter mean=%1.1fpx std=%1.1fpx',mean(error),std(error));
            title(str)
            line([0 0],ylim,'color','k')
            line(xlim,[0 0],'color','k')

            subplot(1,2,2)
            temp=[DATA.difrefix1l]';
            %plot(temp(:,1),temp(:,2),'.b')
            scatter(temp(:,1),temp(:,2),5,1:length(temp))
            xlim([-1000 1000]);ylim([-1000 1000])
            error=sqrt(temp(:,1).^2+temp(:,2).^2);
            str=sprintf('fix first letter mean=%1.1fpx std=%1.1fpx',mean(error),std(error));
            title(str)
            line([0 0],ylim,'color','k')
            line(xlim,[0 0],'color','k')
        end
        function figFix2Cross(DATA)
            figure(9881);clf
            subplot(1,2,1)
            temp=[DATA.diflefixcruz]';
            scatter(temp(:,1),temp(:,2),5,1:length(temp))
            xlim([-100 100]);ylim([-100 100])
            error=sqrt(temp(:,1).^2+temp(:,2).^2);
            str=sprintf('fix cruz mean=%1.1fpx std=%1.1fpx',mean(error),std(error));
            title(str)
            line([0 0],ylim,'color','k')
            line(xlim,[0 0],'color','k')

            subplot(1,2,2)
            temp=[DATA.difrefixcruz]';
            %plot(temp(:,1),temp(:,2),'.b')
            scatter(temp(:,1),temp(:,2),5,1:length(temp))
            xlim([-100 100]);ylim([-100 100])
            error=sqrt(temp(:,1).^2+temp(:,2).^2);
            str=sprintf('fix cruz mean=%1.1fpx std=%1.1fpx',mean(error),std(error));
            title(str)
            line([0 0],ylim,'color','k')
            line(xlim,[0 0],'color','k')
        end
        function plotSplittedSntcs(DATA, trial, init, ESTIM)
            % plotea oraciones con todo lo que tengo, separaciones, fijaciones, asignacion de fijaciones, etc
            iEstim = find(strcmp(DATA(trial).oracion, {ESTIM.oracion}));
            if length(iEstim)>1 || isempty(iEstim)
                disp('Warning: trial not found')
                keyboard
            end
            
            figure(9879)
            clf
            im   = init.colback * ones(init.height, init.width);
            indy = ESTIM(iEstim).posoracion(3):ESTIM(iEstim).posoracion(4)-1;
            indx = ESTIM(iEstim).posoracion(1):ESTIM(iEstim).posoracion(2)-1;
            im(indy,indx) = ESTIM(iEstim).imagen(:,:,1);            
            imagesc(im)
            colormap(gray)

            hold on
            mvp = init.height/2 + init.height*.2;
            line([ESTIM(iEstim).posoracion(2) ESTIM(iEstim).posoracion(1)],[mvp mvp] )

            for j=1:length(DATA(trial).spaces)
                line(DATA(trial).spaces(j)*[1 1],ylim,'color','k','linestyle',':')
            end

            lefix = DATA(trial).lefix;
            if ~isempty(lefix)
                plot(lefix(:,4),lefix(:,5),'or')
                for i=1:size(lefix,1)   %muestro fijaciones ojo izquierdo
                    texto=[num2str(lefix(i,3)) ', ' num2str(DATA(trial).lefixasig(i))];
                    text(lefix(i,4),lefix(i,5)+150,texto,'color','r','rotation',90)%muestro duracion
                    text(lefix(i,4),lefix(i,5)+50,num2str(i),'color','r')%muestro numero de fijacion
                    line([lefix(i,4) lefix(i,4)],[lefix(i,5) lefix(i,5)+50],'color','r')
                end
            end
            refix = DATA(trial).refix;       
            if ~isempty(refix)
                plot(refix(:,4),refix(:,5),'ob')    
                for i=1:size(refix,1)    %muestro fijaciones ojo derecho
                    texto=[num2str(refix(i,3)) ', ' num2str(DATA(trial).refixasig(i))];        
                    text(refix(i,4),refix(i,5)-100,texto,'color','b','rotation',90)%muestro duracion
                    text(refix(i,4),refix(i,5)-50,num2str(i),'color','b')%muestro numero de fijacion
                    line([refix(i,4) refix(i,4)],[refix(i,5) refix(i,5)-50],'color','b')
                end
            end
            xlim([DATA(trial).posoracion(1)-50 DATA(trial).posoracion(2)+50])
            ylim([0 init.height])

            text(300,580,'LEFT','FontSize',18,'FontWeight','bold','color','r')
            text(300,220,'RIGHT','FontSize',18,'FontWeight','bold','color','b')
            
            drawnow
        end
        function plotAllFix(DATA,IM,init)
            figure(9880);clf;                        
            axes('position', [.4 .11 .5 .815])
            hold all
            imagesc(IM)
            mycolormap=[[0 .5 0];[1 1 1]];
            colormap(mycolormap)
            axis ij
            lefix=[];
            refix=[];
            for i=1:length(DATA)
                lefix=[lefix ; DATA(i).lefix];
                refix=[refix ; DATA(i).refix];
            end
            plot(lefix(:,4),lefix(:,5),'.r')
            plot(refix(:,4),refix(:,5),'.b')
            legend({'left' 'right'})
            title(['Best eye: ' DATA(1).eye])
            xlim([0 init.width])
            ylim([0 init.height])
            plot(xlim,ylim,'ok','linewidth',4)
            
            axes('position', [.05 .11 .34 .815])
            axis ij
            hold all            
            posvert=0:10:768;
            h=hist(lefix(:,5),posvert);
            semilogx(h,posvert,'r')
            h=hist(refix(:,5),posvert);
            semilogx(h,posvert,'b')
            set(gca,'xscale','log')
            ylim([0 init.height])
        end
        
    end%methods
end% classdef

%% generate ESTIM
function DATA  = parseSentence(DATA)
    try
        fprintf('\tParse Sentence\n')    
        for trial=1:length(DATA)
%             sentence = strtrim(DATA(trial).oracion);
            sentence = cleanTxt(DATA(trial).oracion);
            spaces   = strfind(sentence,' '); 
            spaces   = [0 spaces length(sentence)];        
            words    = {};
            for iWord = 1:(length(spaces)-1)
                chars   = (spaces(iWord)+1) : (spaces(iWord+1));
                palabra = strtrim(sentence(chars));
                words   = [words palabra];
            end
            DATA(trial).palabras = words;
        end
    catch ME
        ME
        keyboard
    end
end
function ESTIM = addLexEspFreq(ESTIM, M)
    fprintf('\tAdd word Frequency from LexEsp\n')
    % inputs:
    %         M:      LexEsp matrix with freq 
    %         ESTIM:  Estimuli matrix

    charRaros = '[,:;.!¡?¿"]';
    words = [ESTIM.palabras];
    words = regexprep(words,charRaros ,''); % delete comas
    words = regexprep(words,'^celest$','celeste'); % delete comas
    
    [tf loc]=ismember(lower(words), lower({M.palabra})); %locate words in M

    % Word not found -> loc = 0
    loc(loc==0)   = length(M)+1; % replace by N+1
    M(end+1).frec = 0;           % freq(N+1) = 0
    M(end).pal    = '';          % Set as empty word
    M(end).catmax = 'x';          % Set as empty word
    M(end).categorias.frec = 0;
    M(end).categorias.categoria = 'x';

    thisWord = 1;
    thisSntc = 1;
    while thisWord <= length(words)
        lenThisSntc = length(ESTIM(thisSntc).palabras);
        w1        = words{thisWord};
        w2        = ESTIM(thisSntc).palabras{1};
        w2        = regexprep(w2,charRaros,'');
        
        if strcmp(w1, w2) % Check if 1st word is equal
            indicesSnt = thisWord + (1:lenThisSntc)-1;
            ESTIM(thisSntc).freq = [M(loc(indicesSnt)).frec]+1;
            ESTIM(thisSntc).catgram = arrayfun(@(x) x.catmax(1), generateCatMax(M(loc(indicesSnt))));
            ESTIM(thisSntc).length  = arrayfun(@(x) length(x{:}), ESTIM(thisSntc).palabras);
        else
            error(['Warning: 1st word is not equal!!! ' w1 ' ' w2])
        end    
        
        thisSntc = thisSntc + 1;
        thisWord = thisWord + lenThisSntc;
    end
end
function DATA  = addPred(DATA, preds)
    fprintf('\tAdding Pred to ESTIM\n')
    try
    preds.WordID = 1000*(preds.id_text) + preds.palNum;
    for iTr = 1:length(DATA)
        DATA(iTr).pos   = [1:length(DATA(iTr).palabras)];
        DATA(iTr).posRel= DATA(iTr).pos./max(DATA(iTr).pos);
        DATA(iTr).wrdID = 1000*DATA(iTr).ind + (DATA(iTr).pos-1);
        DATA(iTr).SntType =  ones(1, length(DATA(iTr).palabras))*...
                                        DATA(iTr).tipo;

        
        DATA(iTr).pred = [];
        DATA(iTr).palNumGobal = [];
        for iWrd = 1:length(DATA(iTr).wrdID)
            wrdID = DATA(iTr).wrdID(iWrd);
            wrdIDPred = wrdID;
            if wrdIDPred>=105000
                wrdIDPred=wrdID+1000;
            end
            tIndPred = find(preds.wordID == wrdIDPred);
            tPred = preds(tIndPred, :);
            
            wrdPred = cleanTxt(tPred.palabra{1});
            wrdDATA = cleanTxt(DATA(iTr).palabras{iWrd});
            if ~strcmpi(wrdPred,wrdDATA)
                keyboard
            end
            DATA(iTr).pred = [DATA(iTr).pred tPred.pred' ];
            DATA(iTr).palNumGobal = [DATA(iTr).palNumGobal tPred.palNumGobal' ];
        end
        DATA(iTr).predPrev = [NaN DATA(iTr).pred(1:end-1)];
        DATA(iTr).predNext = [DATA(iTr).pred(2:end) NaN];
        
    end
    catch ME
        keyboard
    end



end
function s     = cleanTxt(s)
    repChar = '[,.¿?¡!"]';
    s = regexprep(s,repChar,'');
    s = regexprep(s,'á','a');
    s = regexprep(s,'é','e');
    s = regexprep(s,'í','i');
    s = regexprep(s,'ó','o');
    s = regexprep(s,'ú','u');

end
function pals  = generateCatMax(pals)
%     pal = M(31177)
try
    for i = 1:length(pals)
        [~,ind] = max([pals(i).categorias.frec]);
        pals(i).catmax = pals(i).categorias(ind).categoria;
    end
catch
    keyboard
end
end
function ESTIM = addOrigTextInfo(ESTIM, oracInfo)
    fprintf('\tAdding Orig Text Info to ESTIM\n')
    a = {oracInfo.oracion};
    a = cellfun(@(x) cleanTxt(x), a, 'UniformOutput',false);

    for iEstim=1:length(ESTIM)
        thisOrac = cleanTxt(ESTIM(iEstim).oracion);
        ind = strcmpi(thisOrac,a{:});
        if sum(ind)==1
            ESTIM(iEstim).cuento  = oracInfo(ind,:).Nombre;
            ESTIM(iEstim).posOrac = oracInfo(ind,:).NumeroDeOracionEnCuento;
        else
            ESTIM(iEstim).cuento  = {'ERROR'} ;
            ESTIM(iEstim).posOrac = -100000;
        end
    end

end
%% LOAD ASC functions
function [blockLim, headLim, expLim]  = findCalibrations(C)
    % blockLim: from las calibration to last sample
    % headLim: from calibration to calibration end
    % expeLim: from calibration end to last sample

    fprintf('Finding calibrations marks\n')
    [stLinesNum, ~]           = findTextInFile(C, {'>>>>>>> CALIBRATION'}, 0);
    fprintf('Finding experiment start marks\n')
    [modeLinesNum, modeLines] = findTextInFile(C, {'!MODE'}, 0);

    blockLim = [];
    headLim  = [];
    expLim   = [];
    % For each block find the last calibration
    for i = 1:length(modeLinesNum)
        mode     = strsplit(strtrim(modeLines{i}), ' '); 
        mode     = mode(length(mode));
        previous = find((stLinesNum  - modeLinesNum(i)) < 0);
        next     = stLinesNum(find((stLinesNum  - modeLinesNum(i)) > 0, 1, 'first'))-1;
        if isempty(next); next = length(C); end
        
        if strcmpi(mode, 'L') || strcmpi(mode, 'R')
            % If MONO, I only care for the last calibration
            calStart = stLinesNum(length(previous));
        elseif strcmpi(mode, 'LR')
            % If BINO, I need the last 2 calibrations (L and R)
            calStart = stLinesNum(length(previous)-1);
        end
        
        blockLim = [blockLim ; [calStart next]];
        headLim  = [headLim  ; [calStart modeLinesNum(i)]];
        expLim   = [expLim   ; [modeLinesNum(i) next]];
    end

end
function C                  = loadFile(filename)
    fid = fopen(filename);
    C   = textscan(fid, '%s','delimiter', '\n');
    C   = C{1};
    fclose(fid);
% 
% fid   = fopen(filename);
%     count = 0;
%     i     = 0;
%     C     = {};
%     while isempty(ferror(fid)) 
%         count = count + 1;
%         tline = fgetl(fid);    % read one line of file
%         C{count} = [tline ' ']; %add a space to add empty lines too
%     end
%     fclose(fid);
end
function [line, lines]      = findTextInFile(C, texts, first)
    % find one of the texts in file from line 1 to line maxlines
    % output: # of lines and text of line
    
    line  = [];
    lines = [];
    for i = 1:length(texts)% find each of str in texts
        if first == 1
            counter = 0;
%             keyboard
            while isempty(line) && counter < length(C)
                counter = counter+1;
                tline = C{counter};    
                if ~isempty(strfind(tline,texts{i})) 
                    line = [line counter];
                    lines = [lines tline];
                    return 
                end
                %    disp([num2str(contador) tline])
            end
        else
            a = cellfun(@(x) ~isempty(strfind(x,texts{i})), C);
            index = find(a);
            line  = [line index];
            lines = [lines C(line)];
        end                
        
    end
    
    if isempty(line)
        tline = [];
    end
end
function all                = analysisCalibration(C, all)
    all.mode         = eyelinkMode(C); % look for eyelink mode
    all.eye          = findEye(C);     % look for tracked eye
    all.srate        = findSamplingRate(C);%look for sampling rate
    all.driftcorrect = findDriftCorrect(C);
    all              = findBestEye(all);
    
    lToStart = all.expLim(1)-all.blockLim(1);
    tmp = readFileNoheader(C, lToStart);

    % Column definitions of samples and eye events 
    all.fieldnames.fixations    = '<stime> <etime> <dur> <axp> <ayp> <aps>';
    all.fieldnames.saccades     = '<stime> <etime> <dur> <sxp> <syp> <exp> <eyp> <ampl> <pv>';
    all.fieldnames.blinks       = '<stime> <etime> <dur>';
    all.fieldnames.samplesmonoc = '<time> <xp> <yp> <ps>';
    all.fieldnames.samplesbinoc = '<time> <xpl> <ypl> <psl> <xpr> <ypr> <psr>';
  
%     keyboard
    [dataEvents datasamples] = splitSampleEvents(tmp);

    all.samples = findSamples(datasamples, all.eye);

    all.resac = findEvents(dataEvents,'ESACC R');
    all.lesac = findEvents(dataEvents,'ESACC L');
    all.refix = findEvents(dataEvents,'EFIX R');
    all.lefix = findEvents(dataEvents,'EFIX L');
    all.rebli = findEvents(dataEvents,'EBLINK R');
    all.lebli = findEvents(dataEvents,'EBLINK L');

    [all.msgtime msgline] = findEvents(dataEvents,'MSG');
    all.msg               = dataEvents(msgline);   
    all                   = removeTimeFromMsg(all);%as it is, the string of the messages include the time. here i remove it, lo leave only de the message

end
function mode               = eyelinkMode(C)
    % Look for (M)onocular, (B)inocular o (R)emote
    mode = [];
    [linea textline] = findTextInFile(C, {'ELCLCFG'},1);
    if     strfind(textline,'RTABLE') > 0 % remote
        mode = 'RTABLE';
    elseif strfind(textline,'BTABLE') > 0 % binocular
        mode = 'BTABLE';
    elseif strfind(textline,'MTABLE') > 0 % monocular
        mode = 'MTABLE';
    end
    disp(['Mode: ' mode]);    
end
function eye                = findEye(C)
    % find used eye
    [line, textline] = findTextInFile(C, {'START'}, 1);
   
    if ~isempty(line)
        rigth = strfind(textline,'RIGHT');      
        left  = strfind(textline,'LEFT');
        if ~isempty(rigth) && ~isempty(left)
            eye = 'BOTH';
        elseif ~isempty(rigth) && isempty(left)
            eye = 'RIGHT';
        elseif isempty(rigth) && ~isempty(left)
            eye = 'LEFT';
        else
            eye='??';
            disp('Could not recognize eye')
        end        
    else
        eye=nan;        
    end
    disp(['Eye: ' eye]);    
end
function srate              = findSamplingRate(C)
    
    [line, textline] = findTextInFile(C,{'RATE'},1);
    if ~isempty(line)
        pos   = strfind(textline,'RATE');
        srate = sscanf(textline(pos+4:end),'%f');
    else
        srate=[];
    end
    disp(['Sampling Rate: ' num2str(srate)]);
end
function dc                 = findDriftCorrect(C)
    % output: first drift correct found
    % format: [[dcxl dcyl] [dcxr dcyr]]

    [line, textline] = findTextInFile(C, {'DRIFTCORRECT LR LEFT' 'DRIFTCORRECT L LEFT'},1);        
    if ~isempty(line)
        posicion=strfind(textline,'deg.');
        dcLeft=sscanf(textline(posicion+4:end),'%f,%f');
    else
        dcLeft = [nan; nan];
    end
    
    [line, textline] = findTextInFile(C, {'DRIFTCORRECT LR RIGHT' 'DRIFTCORRECT R RIGHT'},1);        
    if ~isempty(line)
        posicion=strfind(textline,'deg.');
        dcRight=sscanf(textline(posicion+4:end),'%f,%f');        
    else
        dcRight=[nan; nan];
    end
    dc=[dcLeft dcRight]';
end
function out                = readFileNoheader(C, S)
    out = C(S(1):end);
end
function all                = findBestEye(all)
    fprintf('Finding best eye:\n')
    [line, lines] = findTextInFile(all.header, {'!CAL VALIDATION'},0);


    if strcmpi(all.eye, 'RIGHT') || strcmpi(all.eye, 'LEFT')
        splited = strsplit(lines{end});
        ind = find(cellfun(@(x) ~isempty(x), (strfind(splited,'ERROR'))));
        all.bestCal = all.eye;
        all.calErr  = str2num(splited{ind+1});
    elseif strcmpi(all.eye, 'BOTH')
        splitedR = strsplit(lines{end});
        indR = find(cellfun(@(x) ~isempty(x), (strfind(splitedR,'ERROR'))));
        
        splitedL = strsplit(lines{end-1});
        indL = find(cellfun(@(x) ~isempty(x), (strfind(splitedL,'ERROR'))));
        
        fprintf('\tRIGHT: %.2f  LEFT: %.2f\n',  str2num(splitedR{indR+1}),...
                                                str2num(splitedL{indL+1}))
                                        
        if str2num(splitedR{indR+1}) < str2num(splitedL{indL+1})
            all.bestCal = 'RIGTH';
            all.calErr  = str2num(splitedR{indR+1});
        else
            all.bestCal = 'LEFT';
            all.calErr  = str2num(splitedL{indL+1});
        end        
        fprintf('\tBest eye: %s\n', all.bestCal)

    else 
        keyboard
        fprintf('Unknwon eye\n')
    end

end
function [envents, samples] = splitSampleEvents(data)
    % Delete non-event cells
    ind1 = myStrMatch('E', data);% from ESACC, EFIX, EBLINK, y EVENTS
    ind2 = myStrMatch('S', data);% from SSACC, SFIX, SBLINK, START y SAMPLES
    ind3 = myStrMatch('M', data);% from MSG
    ind4 = myStrMatch('P', data);% from PUPIL    
    ind5 = myStrMatch('V', data);% from VPRESCALER
    ind6 = myStrMatch('I', data);% from INPUT
    ind7 = myStrMatch('B', data);% from BUTTON
    all  = [ind1; ind2; ind3; ind4; ind5; ind6; ind7];
    ind  = setxor(1:length(data), all);
    
    envents = data(all);
    samples = data(ind)';
end
function coinc              = myStrMatch(string,data)
    coinc    = [];
    quantos  = 200000;
    pos      = 0;
    counter  = 0;
    while pos < length(data);
        if (pos+quantos) > length(data)
            indices = (pos+1):length(data);
        else
            indices = pos+(1:quantos);
        end
        toAdd     = pos+strmatch(string,data(indices));
        pos       = pos+quantos;
        coinc     = [coinc; toAdd];        
        counter   = counter+1;
    end
        
end
function matrix             = findSamples(data,eye)
    try
    fprintf(1,'%d samples to process:\n  ',length(data));   
    tic         
    lengthstr  = 0;
%     keyboard
    if isnan(eye)
        matrix=[];
        disp('Unknown mode')
        return
    elseif strcmp(eye,'LEFT') | strcmp(eye,'RIGHT') 
        matrix    = nan(length(data),4);
        for i = 1:length(data);  
            temp      = sscanf(char(data(i)),'%f');
            if length(temp)==4
                matrix(i,:) = temp;
            elseif length(temp) == 1
                matrix(i,:) = nan;
                matrix(i,1) = temp;
            end
            % Print 
            if mod(i,100000)==0;
                str = sprintf('%d00k...',i/100000);                
                for j=1:lengthstr;fprintf('\b');end
                fprintf('%s',str)
                lengthstr = length(str);
            end                       
        end
    elseif regexp(eye,'BOTH') % if binocular
        matrix=nan(length(data),7);
        for i = 1:length(data);  
            if length(char(data(i)))>0
            temp = extractDataFromBinoc(char(data(i)));
            if length(temp)==7
                matrix(i,:) = temp';
            else
                matrix(i,:) = nan;
                matrix(i,1) = temp';
            end
            
            % Print 
            if mod(i,100000)==0;
                str = sprintf('%d00k...',i/100000);                                
                for j=1:lengthstr;fprintf('\b');end
                fprintf('%s',str)
                lengthstr = length(str);
            end                      
            end

        end
    else
        matrix=[];
        disp('Unknown mode')
        return
    end
        
    index           = isnan(matrix(:,1));
    matrix(index,:) = [];

    time = toc;
    fprintf(1,'\n%d samples found in %2.2f seg.\nSpeed: %0.0f Samples/seg\n',length(matrix),time,length(matrix)/time);
    catch ME
        keyboard
        sprintf('\n\n Fail on line %d, probably a recalibration was done or near begining.\nCheck ASC in these lines.\n', i)    
        ME
    end
        

end
function out                = extractDataFromBinoc(str)
try
    % Optimal for all data
    res{1} = sscanf(str,'%f');
    % If res has 7 columns, all is done.
    if length(res{1}) == 7 
        out = res{1};
        return 
    end
    
    % If not, lokk for the correct one to use    
    res{2} = sscanf(str,'%f .  .  %f .  .  %f');   % optimal for none data
    res{3} = sscanf(str,'%f %f %f %f .  .  %f');   % optimal for left only
    res{4} = sscanf(str,'%f . . %f %f %f %f');   % optimal for right only
    
    long = [length(res{1}) length(res{2}) length(res{3}) length(res{4})];
    m    = find(long == max(long),1);
    switch m
        case 1
            out = res{1};
        case 2
            out = [res{2}(1); nan(6,1)];
        case 3
            out = [res{3}(1:4); nan(3,1)];
        case 4
            out = [res{4}(1); nan(3,1); res{4}(3:5)];
    end
    out = out';
catch ME
    ME
    disp('ERROR: check last  line of .asc. Probably truncated file')
    keyboard
end
end
function [matrix, indices]  = findEvents(data, eventName)

% Set the number of fields in each type of event
switch eventName
   case {'EFIX L','EFIX R' }
      numbers = 6; %length of array if events are fixations
   case {'ESACC L','ESACC R'}
      numbers = 9; %length of array if events are saccades
   case {'EBLINK L','EBLINK R'}
      numbers = 3; %length of array if events are blinks
   case 'MSG'
      numbers = 1; %length of array if events are msg
    otherwise
       disp('nose')       
end

indices = myStrMatch(eventName, data);
matrix  = nan(length(indices),numbers);
try
    for i=1:length(indices);
        temp=sscanf(data{indices(i)},[eventName ' %f %f %f %f %f %f %f %f %f']);
        if length(temp) == numbers
            matrix(i,1:numbers) = temp(1:numbers);
        end
    end
    matrix(isnan(matrix(:,1)),:)=[];
catch ME
    ME
    keyboard
end
disp([num2str(length(indices)) ' events ' eventName ' found.'])
end
function all                = removeTimeFromMsg(all)
% Removes the time from todo.msg, leaving only the msg
for i=1:length(all.msg)
    % Find nextindex
    [A, count, errmsg, nextindex]=sscanf(all.msg{i},'MSG%f');
    % nextindex is the index of char after MSG and a float
    all.msg{i}=all.msg{i}(nextindex+1:end);
end
end
function thisPart           = removePractice(thisPart,nTrialPract)
    ends = find(ismember(thisPart.event,[224]));
    iE   = ends(nTrialPract);
    
    thisPart.msg = thisPart.msg(iE+1:end);
    thisPart.event = thisPart.event(iE+1:end);
    thisPart.msgtime = thisPart.msgtime(iE+1:end);
end
function all   = msg2event(all)
    all.event = cellfun(@(x) extractNum(x) , all.msg);
end

%% addEM()
function [DATA, all] = recognizeLetterAndWord(DATA,...
                                               all,init,...
                                               block,...
                                               SUJ, iSuj)
                                           
    % Amount of trials per block 
    trPerBlock = 42; 
    blockStr = trPerBlock*(block-1)+1;
    blockEnd = trPerBlock*block; 

    % In case last block has different amuount of trials
    if block==6;blockEnd=219;end
    DATA = DATA([blockStr:blockEnd]);

    % No se si es necesario
    all = interpolateBlinksSaccades(all);
    
    % Pixel for character
    ppc = calculatePPC(DATA);
    DATA = arrayfun(@(x) setfield(x,'ppc',ppc), DATA);

    % Max Vertical Pos for fixations
    mvp = init.height/2 + init.height*.1;
    
    fprintf('\tBest eye: %s\n\n', all.bestCal) 
    DATA = addFix(all,DATA,mvp,ppc);
    DATA = addSpaces(DATA, ppc);
    DATA = assignFixToWords(DATA, init);
    DATA = assignFixToChar(DATA, ppc);
    DATA = assignFixToFirstChar(all, DATA);
%             DATA = addFixCross(all, DATA, init);
%             DATA = addRT(all, DATA);
%             DATA = addPupil(all, DATA, SUJ(iSuj));
%             DATA = addMsgsToTrial(all, DATA);    
      
    for i=1:length(DATA)
        DATA(i).sujnum  = iSuj;
        DATA(i).sujname = SUJ; 
        DATA(i).block   = block;
        DATA(i).trial   = i;
        DATA(i).eye     = all.bestCal;
    end
    
end

function ppc   = calculatePPC(DATA)
    % length of sentence image / length (in chars) of sentence
    % mean of all the sentences
    tmp = [];
    for i = 1:length(DATA)
        tmp = [tmp size(DATA(1).imagen,2)/length(DATA(1).oracion)];
    end

    ppc = mean(tmp); % Pixel per character
end
function num   = extractNum(C)
    sC = split(C);
    num = str2double(sC{end});
end
function DATA  = addFix(all, DATA, mvp, ppc)
try 
    % Add all the fixations within the trial
%      EVENTO                      | marca ET      
% Base                             |               
% inicio expe                      | keyword 244   
% inicio bloque                    | keyword 254   
% cruz de fijacion                 | keyword i     
% aparece punto rojo               | keyword 220   
% aparece text, start lectura Asil | keyword 240   
% aparece text, start lectura Cont | keyword 231   
% aparece text, start lectura Train| keyword 233   
% desaparece texto, fin lectura	   | keyword 221   
% aparece pregunta                 | keyword 222   
% responde, desparece pregunta	   | keyword 223   
% fin trial	                       | keyword 224   
% Final bloque                     | keyword 255   
% Final expe                       | keyword 245   
    fprintf('\tAdd fixations\n')
    indStr = find(all.event == 240 | all.event == 231);
    indEnd = find(all.event == 221);
    indEnd = indEnd(end+1-length(indStr):end);

    for trial = 1:length(indEnd) 

        tStr = all.msgtime(indStr(trial)); % Trial strat time
        tEnd = all.msgtime(indEnd(trial)); % Trial end   time
                
        % Rigth eye %%%%%%%%%%%
        refix  = all.refix;
        refix  = refix(refix(:,5)<mvp,:);
       
        % Left eye %%%%%%%%%%%
        lefix  = all.lefix;
        lefix  = lefix(lefix(:,5)<mvp,:);
       
        % Both eyes %%%%%%%%%%%
        bfix = {refix lefix};

        indexes = []; 
        for iEye = 1:length(bfix)
            tfix   = bfix{iEye};
            fixind = find(tfix(:,2)>=tStr & tfix(:,2)<=tEnd);  % Find all fix

            % From start to end marks
%             fixind = [min(fixind)-1; fixind]; % Add a Fix at begining 
            if ~isempty(fixind)
                if  fixind(end) > length(refix)
                    fixind(end) = [];
                end        
            end
            indexes{iEye} = fixind;
        end

        DATA(trial).refix = refix(indexes{1},:); % Save Fix of trial N
        DATA(trial).lefix = lefix(indexes{2},:); % Save Fix of trial N

        % Sometimes right dot dont ends trial. 
        % Find the 1st fix at the right of sentnces and delete posterios
        sntcEndPos = DATA(trial).posoracion(2) + 2*ppc; % Sentence + 2 Char
        hPosFixR   = DATA(trial).refix(:,4);
        hPosFixL   = DATA(trial).lefix(:,4);
        firstEndR  = find(hPosFixR > sntcEndPos, 1, 'first');
        firstEndL  = find(hPosFixL > sntcEndPos, 1, 'first');

        if ~isempty(firstEndR)
            DATA(trial).refix = DATA(trial).refix(1:firstEndR,:); 
        end
        if ~isempty(firstEndL)
            DATA(trial).lefix = DATA(trial).lefix(1:firstEndL,:); 
        end
       
    end
catch ME
    ME
    keyboard
end
end
function DATA  = addSpaces(DATA,ppc)
    fprintf('\tAdd Spaces\n')
    try
        for trial=1:length(DATA)
            spaces = strfind(DATA(trial).oracion,' ');
            spaces = [0 spaces length(DATA(trial).oracion)+1];        
            if strcmp(DATA(trial).oracion(end),' ')
                spaces(end) = [];
            end
            DATA(trial).spaces = DATA(trial).posoracion(1)+(spaces-.5)*ppc;
        end
    catch ME
        disp(ME)
        keyboard
    end
end
function DATA  = assignFixToWords(DATA, init)
fprintf('\tAssign Fixations of words to Data\n')
try    
    for trial = 1:length(DATA)
        edges=[0 DATA(trial).spaces init.width];   
        
        if ~isempty(DATA(trial).lefix)
            [n bin] = histc(DATA(trial).lefix(:,4),edges);
            DATA(trial).lefixasig = bin-1;
        else
            DATA(trial).lefixasig = [];
        end
        
        if ~isempty(DATA(trial).refix)
            [n bin] = histc(DATA(trial).refix(:,4),edges);        
            DATA(trial).refixasig = bin - 1;        
        else
            DATA(trial).refixasig = [];            
        end
        
    end    
catch ME
    disp(ME)
    keyboard
end
end
function DATA  = assignFixToChar(DATA, ppc)
fprintf('\tAssign Fixations of chars to Data\n')
try
    eyes = {'lefix','refix'};
    for trial=1:length(DATA)
        pos = DATA(trial).posoracion;
        
        for iEye = 1:length(eyes)
            if ~isempty(DATA(trial).(eyes{iEye}))
                % Fix Pos in chars
                poslChar = (DATA(trial).(eyes{iEye})(:,4)-pos(1))/ppc+1; 
                spaces   = [0 strfind(DATA(trial).oracion,' ') 1000];
                wordStrat=nan(size(poslChar));

                for i = 1:length(poslChar) % for each fix
                    ind = find(spaces > poslChar(i), 1); % find word
                    if  ind > 1 && ...
                        poslChar(i) > 0 && ...
                        poslChar(i) < length(DATA(trial).oracion)
                    
                        wordStrat(i) = spaces(ind-1); % Save
                    end
                end
                % SUbstract word strart from fix position
                DATA(trial).([eyes{iEye} 'letra']) = poslChar - wordStrat; 
            else
                DATA(trial).([eyes{iEye} 'letra']) =[];
            end
        end

    end
catch ME
    disp(ME)
    keyboard
end
end
function DATA  = assignFixToFirstChar(all,DATA)
try
    fprintf('\tAdd fixations to first char\n')
% keyboard
%     indtrialini = find(arrayfun(@(x) ~isempty(x{1}), regexp(all.msg,'keyword 23[01]'))); 

    indtrialini = find(all.event == 240 | all.event == 231);
    indtrialini = indtrialini-2;

    findeRange=(-2:2); % Range 2 fix before and after
    
    for trial=1:length(indtrialini) % for each trial...
        cx = DATA(trial).posoracion(1);
        cy = mean(DATA(trial).posoracion([3 4]));
        posFirstChar = [cx cy];
        
        eyes = {'refix', 'lefix'};
        for iEye = 1:length(eyes)
            e = eyes{iEye};
            fix     = all.(e);
            tini    = all.msgtime(indtrialini(trial));     % Time of trial strat
            fixind  = find(fix(:,1) < tini, 1, 'last');    % Last fix before sentence
            findFix = max([fixind + findeRange(1) 1]) : ...
                      min([fixind + findeRange(end) size(fix,1)]);        
            temp    = fix(findFix, [4 5 ]); 

            [~, indmin] = min(sqrt((temp(:,1)-cx).^2+(temp(:,2)-cy).^2)); % busco la que esta mas cerca del target
            DATA(trial).([e '1char']) = fix(findFix(indmin),:);
            
            n = ['dif' e '1char'];
            if ~isempty(fixind) && ~isempty(DATA(trial).(e))
                DATA(trial).(n) = DATA(trial).(e)([4 5]) - posFirstChar;
            else
                DATA(trial).(n) = [nan nan]';
            end
                
        end
    end
catch ME
    ME
    keyboard
end
end
function NLaunchSite = addNLaunchSite(DATA)
        len = DATA.length;
        LFLP = DATA.EM_LFLP(1:length(len));
        charLeft = len-LFLP;
        skips = [1 find(LFLP==0)];
        space = 1;
        acum = zeros(1,length(len));
        NLaunchSite = zeros(1,length(len));
        for iFix = 2:length(len)
            if ismember(iFix,skips)
                iSkip = find(iFix==skips);
                iStart = skips(iSkip-1);
                iEnd   = skips(iSkip);
                spaces = iEnd-iStart;
                acum(iFix) = sum(charLeft(iStart:iEnd)) + spaces;
            else
                acum(iFix) = charLeft(iFix) + space; 
                NLaunchSite(iFix) = acum(iFix-1) + LFLP(iFix) + space;
            end
        end
end
function all   = interpolateBlinksSaccades(all)
    % Lineal interpolation of samples during blinks and saccades

    % if REMOTE or MONO
    if strcmp(all.mode,'RTABLE') | strcmp(all.mode,'MTABLE') 
        all = interpolateEvents(all, all.lesac, 2:4); % Delete L saccades
        all = interpolateEvents(all, all.resac, 2:4); % Delete R saccades

    % if BINO
    elseif strcmp(all.mode,'BTABLE') 

        if strcmp(all.eye,'RIGHT')
            all=interpolateEvents(all, all.resac, 2:4); % Delete R saccades

        elseif strcmp(all.eye,'LEFT')
            all=interpolateEvents(all, all.lesac, 2:4); % Delete L saccades

        elseif strcmp(all.eye,'BOTH')
            all=interpolateEvents(all, all.lesac, 2:4); % Delete L saccades    
            all=interpolateEvents(all, all.resac, 5:7); % Delete R saccades

        else
            fprintf('Warning: eye not detected')
        end

    end

end
function all   = interpolateEvents(all, events, indRem)

% Delete Events (blinks o saccades) 
% indRem (index to remove) can be:
%                                   2:4 (L eye) 
%                                   5:7 (R eye) 
    time = all.samples(:,1);
    if isempty(events)
        return
    end

    eventstart = events(:,1);
    eventend   = events(:,2);    
    
    for i=1:length(eventstart)-1 % al ultimo lo dejo como estaba
        %si el ultimo evento termina junto con la toma, da error. por eso
        %saque el ultimo. podria eliminar totalmente el ultimo (de todo.samples y
        %de todo.lesac,lefix,resac,refix)
        
       indstart = findsorted(time, eventstart(i));
       indend   = findsorted(time, eventend(i));       
       for j = 1:length(indRem) 
            ind      = indRem(j);
            valstart = all.samples(indstart-1,ind);
            valend   = all.samples(indend+1,ind);
            
            all.samples(indstart:indend,ind)= valstart + ((indstart:indend)-indstart) * (valend-valstart)/(indend-indstart);
       end

    end
end
function ind    = findsorted(data,value)
    % find index of value in data (sorted) by bipartition

    maxind=length(data);
    minind=1;
    currind=round(length(data)/2);

    while (data(currind)~=value && maxind-minind>1)
        if data(currind)>value
            maxind=currind;
            currind=round((maxind+minind)/2);
        else
            minind=currind;
            currind=round((maxind+minind)/2);
        end
    end
    ind=currind;
end